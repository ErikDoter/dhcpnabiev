import re

from directory_service.transport.logon import IPAError
from directory_service.transport.models import BaseTransport, BaseFind, BaseGet, BaseAdd, BaseDelete, BaseMethod
from directory_service.transport.permission import PermissionTransport
from directory_service.transport.privilege import PrivilegeTransport
from directory_service.transport.role import RoleTransport
from directory_service.transport.user import UserTransport
from directory_service.transport.user_group import UserGroupTransport
from directory_service.utils import get_ipa_field, get_result_batch_response_list, pass_empty_modification
from enum import Enum


class DelegationTransport(BaseTransport):

    managed_objects = ('user', 'group', 'host', 'hostgroup', 'orgunits')

    class DelegationObjects(Enum):
        user = UserTransport
        group = UserGroupTransport

    @classmethod
    def find(cls, cn=None, attrs=None, sizelimit=0):

        def filter_names(roles):
            # FIXME: временное решение по исключению дефолтных ролей ипы из списка делегирований

            return [r for r in roles if r.get('cn')[0] not in
                    ('Enrollment Administrator', 'IT Security Specialist', 'IT Specialist', 'Security Architect',
                     'User Administrator', 'helpdesk', 'CIFS server')]

        data = cls.request(cls.Find())
        data = filter_names(data)
        return data

    @classmethod
    def parse_target_filter(cls, data):
        return re.match(r'^\(rbtadp=[*]?(.*)\)$', data).group(1)

    @classmethod
    def update_delegation_objects(cls, cn, data):
        batch = []
        for obj in cls.managed_objects:
            rights = data.get(obj)
            if rights is None:
                continue
            batch.append(cls.Update(ident=cn, attrs=dict(rbtadp=data.get('department'),
                                                         ipapermright=rights,
                                                         type=obj)))
        cls.batch_request(batch)

    @classmethod
    def get(cls, cn=None, attrs=None):

        def get_type_of_permission(permission):
            return get_ipa_field(permission, 'type') or \
                   get_ipa_field(permission, 'ipapermtarget').split(',')[-4].split('=')[-1]

        def extract_department(permissions):
            for perm in permissions:
                department = get_ipa_field(perm, 'extratargetfilter') or get_ipa_field(perm, 'ipapermtarget')
                if '(rbtadp=' in department:
                    department = cls.parse_target_filter(department)
                return department

        role = cls.request(cls.Get(ident=cn))
        privilege = cls.request(PrivilegeTransport.Get(ident=cn))
        batch = []
        for perm_cn in privilege.get('memberof_permission', []):
            if perm_cn and perm_cn.startswith('System'):
                continue
            batch.append(PermissionTransport.Get(ident=perm_cn))

        permissions = get_result_batch_response_list(cls.batch_request(batch))
        for perm in permissions:
            role[get_type_of_permission(perm)] = perm.get('ipapermright')
        role['department'] = extract_department(permissions)
        return role

    @classmethod
    def add(cls, cn=None, attrs=None):
        if all(attrs.get(o, []) == [] for o in cls.managed_objects):
            raise IPAError('Error', 'delegation must have at least 1 permission')
        cls.request(cls.Add(ident=cn, attrs=dict(rbtadp=attrs.get('department'),
                                                 description=attrs.get('description'))))
        cls.update_delegation_objects(cn, attrs)
        return True

    @classmethod
    @pass_empty_modification
    def update(cls, cn=None, department=None, attrs=None):

        def check_for_consistency(delegation, data):
            """Проверка на то, что останется хотя бы 1 permission"""
            for obj in cls.managed_objects:
                obj_for_update = data.get(obj)
                if obj_for_update is not None and len(obj_for_update) == 0:
                    delegation.pop(obj, None)
                else:
                    delegation[obj] = obj_for_update
            if not any(obj in delegation for obj in cls.managed_objects):
                raise IPAError('Error', 'delegation must have at least 1 permission')

        attrs['department'] = attrs.get('department') or department

        check_for_consistency(cls.get(cn), attrs)
        cls.update_delegation_objects(cn, attrs)
        cls.request(RoleTransport.Update(ident=cn, attrs=dict(description=attrs.get('description'))))
        return True

    @classmethod
    def delete(cls, cn=None, objects=None):
        delegations = [list(o.values())[0] for o in objects]
        dels = [cls.Delete(ident=delegation) for delegation in delegations]
        cls.batch_request(
            dels
        )
        return True

    @classmethod
    def get_members(cls, cn=None, member_type=None, attrs=None):
        role = RoleTransport.get(ident=cn)
        member_idents = role.get(f'member_{member_type}', [])
        members = get_result_batch_response_list(
            cls.batch_request([cls.DelegationObjects[member_type].value.Get(ident=user)
                               for user in member_idents])
        )
        return members

    @classmethod
    def add_member(cls, cn=None, member_type=None, attrs=None):

        current_members_idents = [get_ipa_field(m, 'cn') if member_type == 'group' else get_ipa_field(m, 'uid')
                                  for m in cls.get_members(cn, member_type)]
        updated_members = [list(a.values())[0] for a in attrs]
        removed_members = [m for m in current_members_idents if m not in updated_members]

        batch = [cls.AddMember(ident=cn, attrs={member_type: updated_members}),
                 cls.RemoveMember(ident=cn, attrs={member_type: removed_members})]
        cls.batch_request(batch)
        return True

    class Find(BaseFind):
        method = 'role_find'

    class Get(BaseGet):
        method = 'role_show'

    class Add(BaseAdd):
        method = 'right_add'

    class Update(BaseAdd):
        method = 'right_mod'

    class Delete(BaseDelete):
        method = 'right_del'

        def params(self, kwargs):
            data = {}
            data.update(kwargs.get('attrs') or {})
            return data

    class AddMember(BaseMethod):
        method = 'role_add_member'

    class RemoveMember(BaseMethod):
        method = 'role_remove_member'
