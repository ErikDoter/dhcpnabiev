import uuid

from django.conf import settings

from directory_service.serializers.ad_mapping import AdMappingSerializer
from directory_service.transport.ad_mapping import AdMappingTransport
from directory_service.transport.ad_profile import AdProfileTransport
from directory_service.transport.ad_trust import AdTrustTransport
from directory_service.transport.dns_forward_zones import DnsForwardZoneTransport
from directory_service.transport.logon import IPAError
from directory_service.transport.models import BaseTransport
from directory_service.utils import get_result_batch_response_list
from project import ProjectError


class AdConnectionTransport(BaseTransport):

    @classmethod
    def find(cls, ident=None, attrs=None, sizelimit=0):
        result = cls.request([
            AdProfileTransport.Find(ident=ident, attrs=attrs, sizelimit=sizelimit),
            AdTrustTransport.Find(ident=ident, attrs=attrs, sizelimit=sizelimit),
        ])

        # Сливаем данные, как будто был получен объект одного типа
        merged_data = {}
        entity_keys = ('is_profile', 'is_trust')
        for ind, entity_key in enumerate(entity_keys):
            for el in result[ind][1]:
                cn = el.get('cn', [None])[0]
                if not merged_data.get(cn):
                    merged_data[cn] = {key: False for key in entity_keys}
                merged_data[cn][entity_key] = True

        result = [{'cn': [key], **val} for key, val in merged_data.items()]

        return result

    @classmethod
    def delete(cls, ident, attrs=None):
        try:
            AdTrustTransport.delete(ident=ident, attrs=attrs)
        except IPAError:
            pass
        return AdProfileTransport.delete(ident=ident, attrs=attrs)

    @classmethod
    def _get_entities(cls, ident, to_update_objects=None, attrs=None, field_key=None, transport=None):
        entity_names = cls.get(ident, attrs).get(field_key, [])
        entities = get_result_batch_response_list(
            cls.batch_request([transport.Get(ident=cn) for cn in entity_names])
        )
        return entities

    @classmethod
    def _get_entities_by_find(cls, ident, to_update_objects=None, attrs=None, field_key=None, transport=None):
        parent_entity = cls.find(ident, attrs)
        if not parent_entity:
            return []
        entity_names = parent_entity[0].get(field_key, [])
        entities = get_result_batch_response_list(
            cls.batch_request([transport.Get(ident=cn) for cn in entity_names])
        )
        return entities

    @classmethod
    def _delete_entities_by_find(cls, ident, to_update_objects=None, attrs=None, field_key=None, transport=None):
        parent_entity = cls.find(ident, attrs)
        if not parent_entity:
            return []
        entity_names = parent_entity[0].get(field_key, [])
        entities = get_result_batch_response_list(
            cls.batch_request([transport.Delete(ident=cn) for cn in entity_names])
        )
        return entities

    @classmethod
    def get_mappings(cls, ident, to_update_objects=None, attrs=None):
        field_key = 'member_admapping'
        transport = AdMappingTransport
        entities = AdProfileTransport._get_entities_by_find(
            ident=ident,
            to_update_objects=to_update_objects,
            attrs=attrs,
            field_key=field_key,
            transport=transport
        )
        return entities

    @classmethod
    def post_mappings(cls, ident, to_update_objects=None, attrs=None):
        field_key = 'admapping'
        name = '{}/{}/{}'.format(ident, to_update_objects.get('admapping_source_attribute_name'),
                                 to_update_objects.get('admapping_object'))
        admapping_cn = str(uuid.uuid3(uuid.NAMESPACE_X500, name))
        add_attrs = {field_key: admapping_cn}
        mapping_data = {'admapping_common_name': admapping_cn}
        mapping_data.update(to_update_objects)
        serializer = AdMappingSerializer(data=mapping_data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        cls.request(AdProfileTransport.AddMember(ident=ident, attrs=add_attrs))
        return []

    @classmethod
    def delete_mappings(cls, ident, to_update_objects=None, attrs=None):
        pks = [val for el in to_update_objects for key, val in el.items()]
        cls.request(AdMappingTransport.Delete(ident=pks))
        return []

    @classmethod
    def get(cls, ident, attrs=None):
        attrs = attrs or {}
        attrs.update({'vaultpassword': settings.AD_IPA_VAULT_MASTER_KEY})
        batch_requests = [
            DnsForwardZoneTransport.Get(idnsname=ident),
            AdTrustTransport.Find(ident=ident),  # TODO: Сменить на .Get как будет настроен траст
            AdProfileTransport.Get(ident=ident, attrs=attrs),
        ]
        result = cls.batch_request(batch_requests, raise_on_err=False)
        data = {}
        dns_data = result[0][1]
        trust_data = result[1][1][0] if result[1][1] else {}
        profile_data = result[2][1]

        dns_data = dns_data if not dns_data.get('error') else {}
        profile_data = profile_data if not profile_data.get('error') else {}

        if not (trust_data or profile_data):
            raise ProjectError(
                'Not found',
                'AdProfile nor AdTrust not found.',
                code=404,
            )

        data.update({'adconnection_dns_forward_zone': dns_data})
        data.update({'adconnection_domain_trust': trust_data})
        data.update({'adconnection_domain_profile': profile_data})
        data.update({'cn': ident})
        return data

    @classmethod
    def post_reset_password(cls, ident, to_update_objects=None, attrs=None):
        mod_attrs = {
            'rbtaadpassword': to_update_objects.get('adprofile_user_password'),
            'vaultpassword': settings.AD_IPA_VAULT_MASTER_KEY,
        }
        cls.request(AdProfileTransport.Update(ident=ident, attrs=mod_attrs))
        return []
